#!/home/zombie/ailinux-ai-server-backend/.venv/bin/python3
"""
TriStar CLI v2.80 - Multi-LLM Chain Orchestration Command Line Interface

Usage:
    tristar                     # Startet Terminal GUI (TUI)
    tristar --gui / --tui       # Startet Terminal GUI explizit
    tristar chain "<prompt>" [options]
    tristar autoprompt show [--project PROJECT] [--profile PROFILE]
    tristar autoprompt set [options]
    tristar project create <project_id> <name> [--description DESC]
    tristar project list
    tristar project delete <project_id>
    tristar status [chain_id]
    tristar logs <chain_id> [--cycle N]
    tristar cancel <chain_id>
    tristar help

Chain Options:
    --project PROJECT           Project ID
    --max-cycles N              Maximum cycles (default: 10)
    --aggressive                Enable aggressive parallel mode
    --autoprompt-profile NAME   Use named autoprompt profile
    --autoprompt-override TEXT  Ad-hoc autoprompt override
    --wait                      Wait for chain to complete
    --verbose                   Show detailed output

AutoPrompt Options:
    --project PROJECT           Project ID for project-level prompt
    --system-prompt TEXT        System prompt
    --lead-model MODEL          Lead model (default: gemini)
    --worker-models MODELS      Comma-separated worker models

Examples:
    tristar                     # Startet interaktives Terminal GUI
    tristar chain "Implement a REST API for user authentication"
    tristar chain "Analyze codebase" --project myapp --aggressive
    tristar autoprompt show --profile coding
    tristar status chain_abc123
    tristar logs chain_abc123 --cycle 2
"""

import argparse
import asyncio
import sys
import json
import time
from pathlib import Path
from typing import Optional, List
from datetime import datetime

# httpx is required - import separately from optional rich
try:
    import httpx
except ImportError:
    print("Error: httpx library is required. Install with: pip install httpx")
    sys.exit(1)

try:
    from rich.console import Console
    from rich.table import Table
    from rich.panel import Panel
    from rich.progress import Progress, SpinnerColumn, TextColumn
    from rich.markdown import Markdown
    from rich.syntax import Syntax
    HAS_RICH = True
except ImportError:
    HAS_RICH = False
    print("Warning: rich library not installed. Using basic output.")

# Configuration - Use localhost for internal calls (no internet required)
# Primary: localhost (internal)
# Fallback: api.ailinux.me (external)
API_BASE_LOCAL = "http://localhost:9100/v1/tristar"
API_BASE_REMOTE = "https://api.ailinux.me/v1/tristar"
MCP_BASE_LOCAL = "http://localhost:9100/v1/mcp"
MCP_BASE_REMOTE = "https://api.ailinux.me/v1/mcp"

# Default to localhost for internal operations
API_BASE = API_BASE_LOCAL
API_BASE_FALLBACK = API_BASE_REMOTE
MCP_BASE = MCP_BASE_LOCAL
TIMEOUT = 300


class TriStarCLI:
    """TriStar Command Line Interface"""

    def __init__(self, api_base: str = API_BASE, mcp_base: str = MCP_BASE):
        self.api_base = api_base.rstrip("/")
        self.api_base_fallback = API_BASE_FALLBACK.rstrip("/")
        self.mcp_base = mcp_base.rstrip("/")
        self.console = Console() if HAS_RICH else None
        self.use_mcp = True  # Prefer MCP JSON-RPC protocol

    def print(self, message: str, style: str = None):
        """Print message to console"""
        if self.console:
            self.console.print(message, style=style)
        else:
            print(message)

    def print_error(self, message: str):
        """Print error message"""
        self.print(f"[red]Error:[/red] {message}" if HAS_RICH else f"Error: {message}")

    def print_success(self, message: str):
        """Print success message"""
        self.print(f"[green]✓[/green] {message}" if HAS_RICH else f"✓ {message}")

    def print_json(self, data: dict):
        """Print JSON data"""
        if self.console:
            syntax = Syntax(json.dumps(data, indent=2, ensure_ascii=False), "json")
            self.console.print(syntax)
        else:
            print(json.dumps(data, indent=2, ensure_ascii=False))

    async def _mcp_call(self, method: str, params: dict = None) -> dict:
        """Make MCP JSON-RPC 2.0 call"""
        url = self.mcp_base
        payload = {
            "jsonrpc": "2.0",
            "method": method,
            "params": params or {},
            "id": int(time.time() * 1000)
        }

        async with httpx.AsyncClient(timeout=TIMEOUT) as client:
            response = await client.post(url, json=payload)

            if response.status_code >= 400:
                error = response.json() if response.content else {"error": response.text}
                raise Exception(f"MCP error: {error}")

            result = response.json()
            if "error" in result:
                raise Exception(f"MCP error: {result['error']}")

            return result.get("result", {})

    async def _request(
        self,
        method: str,
        endpoint: str,
        data: dict = None,
        params: dict = None,
    ) -> dict:
        """Make API request with fallback"""
        # Try primary URL first
        url = f"{self.api_base}{endpoint}"

        async with httpx.AsyncClient(timeout=TIMEOUT) as client:
            try:
                if method == "GET":
                    response = await client.get(url, params=params)
                elif method == "POST":
                    response = await client.post(url, json=data)
                elif method == "DELETE":
                    response = await client.delete(url)
                else:
                    raise ValueError(f"Unknown method: {method}")

                if response.status_code >= 400:
                    # Try fallback URL
                    fallback_url = f"{self.api_base_fallback}{endpoint}"
                    if method == "GET":
                        response = await client.get(fallback_url, params=params)
                    elif method == "POST":
                        response = await client.post(fallback_url, json=data)
                    elif method == "DELETE":
                        response = await client.delete(fallback_url)

                    if response.status_code >= 400:
                        error = response.json() if response.content else {"error": response.text}
                        raise Exception(f"API error: {error}")

                return response.json()

            except httpx.ConnectError:
                # Try fallback URL on connection error
                fallback_url = f"{self.api_base_fallback}{endpoint}"
                if method == "GET":
                    response = await client.get(fallback_url, params=params)
                elif method == "POST":
                    response = await client.post(fallback_url, json=data)
                elif method == "DELETE":
                    response = await client.delete(fallback_url)
                else:
                    raise ValueError(f"Unknown method: {method}")

                if response.status_code >= 400:
                    error = response.json() if response.content else {"error": response.text}
                    raise Exception(f"API error: {error}")

                return response.json()

    # Chain commands

    async def chain_start(
        self,
        prompt: str,
        project_id: Optional[str] = None,
        max_cycles: int = 10,
        aggressive: bool = False,
        autoprompt_profile: Optional[str] = None,
        autoprompt_override: Optional[str] = None,
        wait: bool = False,
        verbose: bool = False,
    ):
        """Start a new chain"""
        self.print(f"\n[bold]Starting TriStar Chain[/bold]" if HAS_RICH else "Starting TriStar Chain")
        self.print(f"Prompt: {prompt[:100]}..." if len(prompt) > 100 else f"Prompt: {prompt}")

        try:
            result = await self._request("POST", "/chain/start", data={
                "user_prompt": prompt,
                "project_id": project_id,
                "max_cycles": max_cycles,
                "aggressive": aggressive,
                "autoprompt_profile": autoprompt_profile,
                "autoprompt_override": autoprompt_override,
            })

            chain_id = result["chain_id"]
            self.print_success(f"Chain started: {chain_id}")
            self.print(f"Project: {result['project_id']}")
            self.print(f"Max cycles: {max_cycles}")

            if wait:
                await self._wait_for_chain(chain_id, verbose)
            else:
                self.print(f"\nUse 'tristar status {chain_id}' to check progress")

        except Exception as e:
            self.print_error(str(e))
            sys.exit(1)

    async def _wait_for_chain(self, chain_id: str, verbose: bool = False):
        """Wait for chain to complete"""
        self.print("\nWaiting for chain to complete...")

        if HAS_RICH:
            with Progress(
                SpinnerColumn(),
                TextColumn("[progress.description]{task.description}"),
                console=self.console,
            ) as progress:
                task = progress.add_task("Running...", total=None)

                while True:
                    status = await self._request("GET", f"/chain/status/{chain_id}")

                    progress.update(task, description=f"Cycle {status['current_cycle']}/{status['max_cycles']} - {status['status']}")

                    if status["status"] in ("completed", "failed", "cancelled"):
                        break

                    await asyncio.sleep(2)
        else:
            while True:
                status = await self._request("GET", f"/chain/status/{chain_id}")
                print(f"Cycle {status['current_cycle']}/{status['max_cycles']} - {status['status']}")

                if status["status"] in ("completed", "failed", "cancelled"):
                    break

                await asyncio.sleep(2)

        # Show final result
        self.print(f"\n[bold]Chain {status['status'].upper()}[/bold]" if HAS_RICH else f"\nChain {status['status'].upper()}")

        if status.get("final_output"):
            if HAS_RICH:
                self.console.print(Panel(Markdown(status["final_output"]), title="Result"))
            else:
                print("\nResult:")
                print(status["final_output"])

        if status.get("error"):
            self.print_error(status["error"])

    async def chain_status(self, chain_id: str):
        """Get chain status"""
        try:
            status = await self._request("GET", f"/chain/status/{chain_id}")

            if HAS_RICH:
                table = Table(title=f"Chain {chain_id}")
                table.add_column("Property", style="cyan")
                table.add_column("Value", style="green")

                table.add_row("Status", status["status"])
                table.add_row("Project", status["project_id"])
                table.add_row("Cycles", f"{status['current_cycle']}/{status['max_cycles']}")
                table.add_row("Started", status.get("started_at", "N/A"))
                table.add_row("Completed", status.get("completed_at", "N/A"))

                self.console.print(table)

                if status.get("error"):
                    self.print_error(status["error"])

                if status.get("final_output"):
                    self.console.print(Panel(Markdown(status["final_output"][:500]), title="Output Preview"))
            else:
                self.print_json(status)

        except Exception as e:
            self.print_error(str(e))
            sys.exit(1)

    async def chain_logs(self, chain_id: str, cycle: Optional[int] = None):
        """Get chain logs"""
        try:
            params = {"cycle": cycle} if cycle else None
            logs = await self._request("GET", f"/chain/logs/{chain_id}", params=params)
            self.print_json(logs)

        except Exception as e:
            self.print_error(str(e))
            sys.exit(1)

    async def chain_cancel(self, chain_id: str):
        """Cancel a chain"""
        try:
            result = await self._request("POST", f"/chain/cancel/{chain_id}")
            self.print_success(f"Chain {chain_id} cancelled")

        except Exception as e:
            self.print_error(str(e))
            sys.exit(1)

    async def chain_list(self, project_id: Optional[str] = None):
        """List chains"""
        try:
            params = {"project_id": project_id} if project_id else None
            result = await self._request("GET", "/chain/list", params=params)

            if HAS_RICH:
                table = Table(title="Chains")
                table.add_column("Chain ID", style="cyan")
                table.add_column("Project", style="blue")
                table.add_column("Status", style="green")
                table.add_column("Cycles", style="yellow")
                table.add_column("Started", style="dim")

                for chain in result["chains"]:
                    table.add_row(
                        chain["chain_id"],
                        chain["project_id"],
                        chain["status"],
                        f"{chain['total_cycles']}/{chain['max_cycles']}",
                        chain.get("started_at", "N/A")[:19],
                    )

                self.console.print(table)
            else:
                self.print_json(result)

        except Exception as e:
            self.print_error(str(e))
            sys.exit(1)

    # AutoPrompt commands

    async def autoprompt_show(
        self,
        project_id: Optional[str] = None,
        profile: Optional[str] = None,
    ):
        """Show autoprompt configuration"""
        try:
            params = {}
            if project_id:
                params["project_id"] = project_id
            if profile:
                params["profile"] = profile

            result = await self._request("GET", "/autoprompt/show", params=params)

            if HAS_RICH:
                self.console.print(Panel(
                    Syntax(json.dumps(result, indent=2, ensure_ascii=False), "json"),
                    title="AutoPrompt Configuration"
                ))
            else:
                self.print_json(result)

        except Exception as e:
            self.print_error(str(e))
            sys.exit(1)

    async def autoprompt_set(
        self,
        project_id: str,
        system_prompt: Optional[str] = None,
        lead_model: Optional[str] = None,
        worker_models: Optional[List[str]] = None,
    ):
        """Set autoprompt configuration"""
        try:
            data = {"project_id": project_id}
            if system_prompt:
                data["system_prompt"] = system_prompt
            if lead_model:
                data["lead_model"] = lead_model
            if worker_models:
                data["worker_models"] = worker_models

            result = await self._request("POST", "/autoprompt/set", data=data)
            self.print_success(f"AutoPrompt set for project {project_id}")

        except Exception as e:
            self.print_error(str(e))
            sys.exit(1)

    async def autoprompt_list(self):
        """List autoprompt profiles"""
        try:
            result = await self._request("GET", "/autoprompt/list")

            if HAS_RICH:
                table = Table(title="AutoPrompt Profiles")
                table.add_column("Name", style="cyan")
                table.add_column("Type", style="blue")
                table.add_column("Description", style="dim")

                for p in result["profiles"]:
                    table.add_row(p["name"], p["type"], p.get("description", ""))

                self.console.print(table)
            else:
                self.print_json(result)

        except Exception as e:
            self.print_error(str(e))
            sys.exit(1)

    # Project commands

    async def project_create(
        self,
        project_id: str,
        name: str,
        description: str = "",
    ):
        """Create a project"""
        try:
            result = await self._request("POST", "/project/create", data={
                "project_id": project_id,
                "name": name,
                "description": description,
            })
            self.print_success(f"Project created: {project_id}")

        except Exception as e:
            self.print_error(str(e))
            sys.exit(1)

    async def project_list(self):
        """List projects"""
        try:
            result = await self._request("GET", "/project/list")

            if HAS_RICH:
                table = Table(title="Projects")
                table.add_column("ID", style="cyan")
                table.add_column("Name", style="blue")
                table.add_column("Chains", style="yellow")
                table.add_column("Created", style="dim")

                for p in result["projects"]:
                    table.add_row(
                        p["project_id"],
                        p["name"],
                        str(p.get("total_chains", 0)),
                        p.get("created_at", "N/A")[:19],
                    )

                self.console.print(table)
            else:
                self.print_json(result)

        except Exception as e:
            self.print_error(str(e))
            sys.exit(1)

    async def project_delete(self, project_id: str):
        """Delete a project"""
        try:
            result = await self._request("DELETE", f"/project/{project_id}")
            self.print_success(f"Project deleted: {project_id}")

        except Exception as e:
            self.print_error(str(e))
            sys.exit(1)

    # Status command

    async def status(self):
        """Get system status via MCP and REST endpoints"""
        try:
            # Try REST first for TriStar status
            result = await self._request("GET", "/status")

            # Also try to get MCP status
            mcp_status = None
            try:
                mcp_status = await self._mcp_call("initialize", {})
            except Exception:
                pass

            if HAS_RICH:
                status_text = (
                    f"[bold green]TriStar v{result.get('version', '2.80')}[/bold green]\n\n"
                    f"Chains: {result.get('chains', {}).get('total', 0)} total, "
                    f"{result.get('chains', {}).get('running', 0)} running, "
                    f"{result.get('chains', {}).get('completed', 0)} completed\n"
                    f"Projects: {result.get('projects', {}).get('total', 0)}\n"
                    f"AutoPrompt Profiles: {result.get('autoprompts', {}).get('profiles', 0)}"
                )

                if mcp_status:
                    server_info = mcp_status.get("serverInfo", {})
                    tristar_info = server_info.get("tristar", {})
                    status_text += (
                        f"\n\n[bold cyan]MCP Server[/bold cyan]\n"
                        f"Name: {server_info.get('name', 'N/A')}\n"
                        f"Version: {server_info.get('version', 'N/A')}\n"
                        f"TriStar Models: {tristar_info.get('total_models', 0)} "
                        f"({tristar_info.get('initialized_models', 0)} initialized)"
                    )

                self.console.print(Panel(status_text, title="System Status"))
            else:
                output = {
                    "tristar": result,
                    "mcp": mcp_status
                }
                self.print_json(output)

        except Exception as e:
            self.print_error(str(e))
            sys.exit(1)

    async def mcp_tools(self):
        """List available MCP tools"""
        try:
            result = await self._mcp_call("tools/list", {})
            tools = result.get("tools", [])

            if HAS_RICH:
                table = Table(title="MCP Tools")
                table.add_column("Name", style="cyan")
                table.add_column("Description", style="dim")

                for tool in tools:
                    table.add_row(
                        tool.get("name", ""),
                        tool.get("description", "")[:60] + "..."
                    )

                self.console.print(table)
                self.print(f"\nTotal: {len(tools)} tools")
            else:
                self.print_json(result)

        except Exception as e:
            self.print_error(str(e))
            sys.exit(1)

    async def mcp_call(self, tool_name: str, arguments: dict):
        """Call an MCP tool directly"""
        try:
            result = await self._mcp_call("tools/call", {
                "name": tool_name,
                "arguments": arguments
            })
            self.print_json(result)

        except Exception as e:
            self.print_error(str(e))
            sys.exit(1)


def main():
    parser = argparse.ArgumentParser(
        description="TriStar CLI - Multi-LLM Chain Orchestration",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__,
    )

    subparsers = parser.add_subparsers(dest="command", help="Commands")

    # Chain command
    chain_parser = subparsers.add_parser("chain", help="Start a new chain")
    chain_parser.add_argument("prompt", help="The prompt/task")
    chain_parser.add_argument("--project", help="Project ID")
    chain_parser.add_argument("--max-cycles", type=int, default=10, help="Max cycles")
    chain_parser.add_argument("--aggressive", action="store_true", help="Aggressive mode")
    chain_parser.add_argument("--autoprompt-profile", help="AutoPrompt profile")
    chain_parser.add_argument("--autoprompt-override", help="Ad-hoc autoprompt override")
    chain_parser.add_argument("--wait", action="store_true", help="Wait for completion")
    chain_parser.add_argument("--verbose", action="store_true", help="Verbose output")

    # Status command
    status_parser = subparsers.add_parser("status", help="Get status")
    status_parser.add_argument("chain_id", nargs="?", help="Chain ID (optional)")

    # Logs command
    logs_parser = subparsers.add_parser("logs", help="Get chain logs")
    logs_parser.add_argument("chain_id", help="Chain ID")
    logs_parser.add_argument("--cycle", type=int, help="Specific cycle")

    # Cancel command
    cancel_parser = subparsers.add_parser("cancel", help="Cancel a chain")
    cancel_parser.add_argument("chain_id", help="Chain ID")

    # List command
    list_parser = subparsers.add_parser("list", help="List chains")
    list_parser.add_argument("--project", help="Filter by project")

    # AutoPrompt commands
    autoprompt_parser = subparsers.add_parser("autoprompt", help="AutoPrompt management")
    autoprompt_sub = autoprompt_parser.add_subparsers(dest="autoprompt_command")

    ap_show = autoprompt_sub.add_parser("show", help="Show autoprompt")
    ap_show.add_argument("--project", help="Project ID")
    ap_show.add_argument("--profile", help="Profile name")

    ap_set = autoprompt_sub.add_parser("set", help="Set autoprompt")
    ap_set.add_argument("--project", required=True, help="Project ID")
    ap_set.add_argument("--system-prompt", help="System prompt")
    ap_set.add_argument("--lead-model", help="Lead model")
    ap_set.add_argument("--worker-models", help="Comma-separated worker models")

    ap_list = autoprompt_sub.add_parser("list", help="List profiles")

    # Project commands
    project_parser = subparsers.add_parser("project", help="Project management")
    project_sub = project_parser.add_subparsers(dest="project_command")

    proj_create = project_sub.add_parser("create", help="Create project")
    proj_create.add_argument("project_id", help="Project ID")
    proj_create.add_argument("name", help="Project name")
    proj_create.add_argument("--description", default="", help="Description")

    proj_list = project_sub.add_parser("list", help="List projects")

    proj_delete = project_sub.add_parser("delete", help="Delete project")
    proj_delete.add_argument("project_id", help="Project ID")

    # MCP commands
    mcp_parser = subparsers.add_parser("mcp", help="MCP operations")
    mcp_sub = mcp_parser.add_subparsers(dest="mcp_command")

    mcp_tools = mcp_sub.add_parser("tools", help="List MCP tools")

    mcp_call = mcp_sub.add_parser("call", help="Call an MCP tool")
    mcp_call.add_argument("tool_name", help="Tool name")
    mcp_call.add_argument("--args", help="JSON arguments", default="{}")

    mcp_status = mcp_sub.add_parser("status", help="MCP server status")

    # Help command
    help_parser = subparsers.add_parser("help", help="Show help")

    args = parser.parse_args()
    cli = TriStarCLI()

    if args.command == "chain":
        asyncio.run(cli.chain_start(
            prompt=args.prompt,
            project_id=args.project,
            max_cycles=args.max_cycles,
            aggressive=args.aggressive,
            autoprompt_profile=args.autoprompt_profile,
            autoprompt_override=args.autoprompt_override,
            wait=args.wait,
            verbose=args.verbose,
        ))

    elif args.command == "status":
        if args.chain_id:
            asyncio.run(cli.chain_status(args.chain_id))
        else:
            asyncio.run(cli.status())

    elif args.command == "logs":
        asyncio.run(cli.chain_logs(args.chain_id, cycle=args.cycle))

    elif args.command == "cancel":
        asyncio.run(cli.chain_cancel(args.chain_id))

    elif args.command == "list":
        asyncio.run(cli.chain_list(project_id=args.project))

    elif args.command == "autoprompt":
        if args.autoprompt_command == "show":
            asyncio.run(cli.autoprompt_show(
                project_id=args.project,
                profile=args.profile,
            ))
        elif args.autoprompt_command == "set":
            worker_models = args.worker_models.split(",") if args.worker_models else None
            asyncio.run(cli.autoprompt_set(
                project_id=args.project,
                system_prompt=args.system_prompt,
                lead_model=args.lead_model,
                worker_models=worker_models,
            ))
        elif args.autoprompt_command == "list":
            asyncio.run(cli.autoprompt_list())
        else:
            autoprompt_parser.print_help()

    elif args.command == "project":
        if args.project_command == "create":
            asyncio.run(cli.project_create(
                project_id=args.project_id,
                name=args.name,
                description=args.description,
            ))
        elif args.project_command == "list":
            asyncio.run(cli.project_list())
        elif args.project_command == "delete":
            asyncio.run(cli.project_delete(args.project_id))
        else:
            project_parser.print_help()

    elif args.command == "mcp":
        if args.mcp_command == "tools":
            asyncio.run(cli.mcp_tools())
        elif args.mcp_command == "call":
            try:
                arguments = json.loads(args.args)
            except json.JSONDecodeError:
                print("Error: --args must be valid JSON")
                sys.exit(1)
            asyncio.run(cli.mcp_call(args.tool_name, arguments))
        elif args.mcp_command == "status":
            asyncio.run(cli.status())  # Uses combined status
        else:
            mcp_parser.print_help()

    elif args.command == "help":
        parser.print_help()

    elif args.command is None:
        # Keine Argumente = TUI starten
        try:
            from app.cli.tristar_tui import run_tui
            run_tui()
        except ImportError:
            # Fallback wenn Import fehlschlägt
            import subprocess
            tui_path = Path(__file__).parent.parent / "app" / "cli" / "tristar_tui.py"
            if tui_path.exists():
                subprocess.run([sys.executable, str(tui_path)])
            else:
                parser.print_help()
        except KeyboardInterrupt:
            print("\nBeendet.")

    else:
        parser.print_help()


if __name__ == "__main__":
    # Check for --gui / --tui flags before argparse
    if len(sys.argv) == 2 and sys.argv[1] in ("--gui", "--tui", "-g"):
        try:
            # Add parent to path for imports
            sys.path.insert(0, str(Path(__file__).parent.parent))
            from app.cli.tristar_tui import run_tui
            run_tui()
        except ImportError as e:
            print(f"TUI nicht verfügbar: {e}")
            print("Installiere mit: pip install textual")
            sys.exit(1)
        except KeyboardInterrupt:
            print("\nBeendet.")
    else:
        main()
