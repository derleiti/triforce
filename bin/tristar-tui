#!/usr/bin/env python3
"""
TriStar Terminal UI v2.80

A full-featured terminal interface for TriStar/TriForce MCP server management.
Features:
- Live log viewer with filtering
- System prompt editor
- Settings management
- Chain execution and monitoring
- Model status dashboard
- Interactive prompt input

Usage:
    tristar-tui [--api-url URL]
"""

import asyncio
import json
import sys
from datetime import datetime
from pathlib import Path
from typing import Optional, Dict, Any, List

import httpx
from textual.app import App, ComposeResult
from textual.containers import Container, Horizontal, Vertical, ScrollableContainer
from textual.widgets import (
    Header, Footer, Static, Input, Button,
    TextArea, ListView, ListItem, Label,
    TabbedContent, TabPane, DataTable, Log,
    RichLog, Select, Switch, ProgressBar
)
from textual.binding import Binding
from textual.message import Message
from textual.reactive import reactive
from textual import work
from rich.syntax import Syntax
from rich.text import Text
from rich.panel import Panel
from rich.table import Table

# Configuration - Use localhost for internal calls (no internet required)
API_BASE_LOCAL = "http://localhost:9100"
API_BASE_REMOTE = "https://api.ailinux.me"
# Default to localhost for internal operations
API_BASE = API_BASE_LOCAL
MCP_ENDPOINT = f"{API_BASE}/v1/mcp"
TRIFORCE_ENDPOINT = f"{API_BASE}/v1/triforce"
TRISTAR_ENDPOINT = f"{API_BASE}/v1/tristar"


class TriStarClient:
    """Async client for TriStar/TriForce API"""

    def __init__(self, base_url: str = API_BASE):
        self.base_url = base_url.rstrip("/")
        self.client = httpx.AsyncClient(timeout=30.0)

    async def close(self):
        await self.client.aclose()

    # MCP Methods
    async def mcp_call(self, method: str, params: dict = None) -> dict:
        """Make MCP JSON-RPC call"""
        payload = {
            "jsonrpc": "2.0",
            "method": method,
            "params": params or {},
            "id": int(datetime.now().timestamp() * 1000)
        }
        response = await self.client.post(f"{self.base_url}/mcp", json=payload)
        result = response.json()
        if "error" in result:
            raise Exception(result["error"].get("message", str(result["error"])))
        return result.get("result", {})

    async def mcp_tool_call(self, tool_name: str, arguments: dict = None) -> dict:
        """Call an MCP tool"""
        return await self.mcp_call("tools/call", {
            "name": tool_name,
            "arguments": arguments or {}
        })

    async def list_tools(self) -> List[dict]:
        """List all MCP tools"""
        result = await self.mcp_call("tools/list")
        return result.get("tools", [])

    # TriForce Methods
    async def get_status(self) -> dict:
        """Get TriForce system status"""
        response = await self.client.get(f"{self.base_url}/v1/triforce/status")
        return response.json()

    async def get_audit_logs(self, limit: int = 100) -> List[dict]:
        """Get recent audit logs"""
        response = await self.client.get(
            f"{self.base_url}/v1/triforce/audit/recent",
            params={"limit": limit}
        )
        return response.json().get("entries", [])

    async def get_memory_stats(self) -> dict:
        """Get memory statistics"""
        response = await self.client.get(f"{self.base_url}/v1/triforce/memory/stats")
        return response.json()

    # TriStar Methods
    async def get_tristar_status(self) -> dict:
        """Get TriStar status"""
        response = await self.client.get(f"{self.base_url}/v1/tristar/status")
        return response.json()

    async def list_prompts(self) -> List[str]:
        """List system prompts"""
        result = await self.mcp_tool_call("tristar_prompts_list")
        content = result.get("content", [{}])[0].get("text", "{}")
        return json.loads(content).get("prompts", [])

    async def get_prompt(self, name: str) -> str:
        """Get a system prompt content"""
        result = await self.mcp_tool_call("tristar_prompts_get", {"name": name})
        content = result.get("content", [{}])[0].get("text", "{}")
        return json.loads(content).get("content", "")

    async def set_prompt(self, name: str, content: str) -> dict:
        """Set a system prompt"""
        result = await self.mcp_tool_call("tristar_prompts_set", {
            "name": name,
            "content": content
        })
        return result

    async def get_settings(self) -> dict:
        """Get all settings"""
        result = await self.mcp_tool_call("tristar_settings")
        content = result.get("content", [{}])[0].get("text", "{}")
        return json.loads(content)

    async def set_setting(self, key: str, value: Any) -> dict:
        """Set a setting value"""
        result = await self.mcp_tool_call("tristar_settings_set", {
            "key": key,
            "value": value
        })
        return result

    async def get_models(self) -> List[dict]:
        """Get registered models"""
        result = await self.mcp_tool_call("tristar.models")
        content = result.get("content", [{}])[0].get("text", "{}")
        return json.loads(content).get("models", [])

    async def get_agents(self) -> List[dict]:
        """Get CLI agents"""
        result = await self.mcp_tool_call("cli-agents.list")
        content = result.get("content", [{}])[0].get("text", "{}")
        return json.loads(content).get("agents", [])

    async def chat(self, message: str, model: str = "gemini/gemini-2.5-flash") -> str:
        """Send chat message"""
        result = await self.mcp_tool_call("chat", {
            "message": message,
            "model": model
        })
        content = result.get("content", [{}])[0].get("text", "")
        return content

    async def start_chain(self, prompt: str, max_cycles: int = 5) -> dict:
        """Start a TriStar chain"""
        response = await self.client.post(
            f"{self.base_url}/v1/tristar/chain",
            json={"prompt": prompt, "max_cycles": max_cycles}
        )
        return response.json()

    # Agent Control Methods
    async def start_agent(self, agent_id: str) -> dict:
        """Start a CLI agent"""
        result = await self.mcp_tool_call("cli-agents.start", {"agent_id": agent_id})
        content = result.get("content", [{}])[0].get("text", "{}")
        return json.loads(content) if content.startswith("{") else {"status": content}

    async def stop_agent(self, agent_id: str) -> dict:
        """Stop a CLI agent"""
        result = await self.mcp_tool_call("cli-agents.stop", {"agent_id": agent_id})
        content = result.get("content", [{}])[0].get("text", "{}")
        return json.loads(content) if content.startswith("{") else {"status": content}

    async def restart_agent(self, agent_id: str) -> dict:
        """Restart a CLI agent"""
        result = await self.mcp_tool_call("cli-agents.restart", {"agent_id": agent_id})
        content = result.get("content", [{}])[0].get("text", "{}")
        return json.loads(content) if content.startswith("{") else {"status": content}

    async def call_agent(self, agent_id: str, message: str) -> str:
        """Call a CLI agent with a message"""
        result = await self.mcp_tool_call("cli-agents.call", {
            "agent_id": agent_id,
            "message": message
        })
        content = result.get("content", [{}])[0].get("text", "")
        return content


class LogViewer(RichLog):
    """Live log viewer widget"""

    def __init__(self, **kwargs):
        super().__init__(highlight=True, markup=True, **kwargs)


class PromptEditor(Container):
    """System prompt editor widget"""

    def compose(self) -> ComposeResult:
        yield Horizontal(
            Select(
                [(p, p) for p in ["Loading..."]],
                prompt="Select Prompt",
                id="prompt-select"
            ),
            Button("Load", id="btn-load-prompt", variant="primary"),
            Button("Save", id="btn-save-prompt", variant="success"),
            Button("New", id="btn-new-prompt"),
            classes="prompt-controls"
        )
        yield TextArea(id="prompt-editor", language="markdown")


class SettingsPanel(Container):
    """Settings editor panel"""

    def compose(self) -> ComposeResult:
        yield DataTable(id="settings-table")
        yield Horizontal(
            Input(placeholder="Key", id="setting-key"),
            Input(placeholder="Value", id="setting-value"),
            Button("Set", id="btn-set-setting", variant="primary"),
            classes="setting-controls"
        )


class ModelDashboard(Container):
    """Model status dashboard"""

    def compose(self) -> ComposeResult:
        yield DataTable(id="models-table")
        yield Horizontal(
            Button("Refresh", id="btn-refresh-models"),
            Button("Initialize All", id="btn-init-all"),
            classes="model-controls"
        )


class AgentPanel(Container):
    """CLI Agent management panel"""

    def compose(self) -> ComposeResult:
        yield DataTable(id="agents-table")
        yield Horizontal(
            Select(
                [("claude-mcp", "Claude"), ("codex-mcp", "Codex"), ("gemini-mcp", "Gemini")],
                prompt="Agent",
                id="agent-select"
            ),
            Button("Start", id="btn-start-agent", variant="success"),
            Button("Stop", id="btn-stop-agent", variant="error"),
            Button("Restart", id="btn-restart-agent"),
            classes="agent-controls"
        )


class ChatPanel(Container):
    """Chat/Prompt panel"""

    def compose(self) -> ComposeResult:
        yield RichLog(id="chat-output", highlight=True, markup=True)
        yield Horizontal(
            Select(
                [
                    ("gemini/gemini-2.5-flash", "Gemini 2.5 Flash"),
                    ("gemini/gemini-2.5-pro", "Gemini 2.5 Pro"),
                    ("mistral/mistral-large-latest", "Mistral Large"),
                    ("anthropic/claude-sonnet-4", "Claude Sonnet 4"),
                ],
                value="gemini/gemini-2.5-flash",
                id="model-select"
            ),
            id="model-selector"
        )
        yield Input(placeholder="Enter prompt... (Ctrl+Enter to send)", id="chat-input")


class TriStarTUI(App):
    """TriStar Terminal User Interface"""

    CSS = """
    Screen {
        layout: grid;
        grid-size: 1;
        grid-rows: auto 1fr auto;
    }

    #main-container {
        height: 100%;
    }

    TabbedContent {
        height: 100%;
    }

    TabPane {
        padding: 1;
    }

    .prompt-controls, .setting-controls, .model-controls, .agent-controls {
        height: auto;
        padding: 1;
        dock: top;
    }

    #prompt-editor {
        height: 100%;
        min-height: 20;
    }

    #chat-output {
        height: 1fr;
        min-height: 15;
        border: solid green;
    }

    #chat-input {
        dock: bottom;
        margin-top: 1;
    }

    #model-selector {
        dock: bottom;
        height: auto;
        margin-bottom: 1;
    }

    DataTable {
        height: 1fr;
    }

    LogViewer, RichLog {
        height: 100%;
        scrollbar-gutter: stable;
    }

    .log-entry-info {
        color: cyan;
    }

    .log-entry-warning {
        color: yellow;
    }

    .log-entry-error {
        color: red;
    }

    .log-entry-security {
        color: magenta;
    }

    Button {
        margin: 0 1;
    }

    Select {
        width: 30;
    }

    #status-bar {
        dock: bottom;
        height: 1;
        background: $surface;
        padding: 0 1;
    }
    """

    BINDINGS = [
        Binding("q", "quit", "Quit"),
        Binding("r", "refresh", "Refresh"),
        Binding("l", "focus_logs", "Logs"),
        Binding("p", "focus_prompts", "Prompts"),
        Binding("s", "focus_settings", "Settings"),
        Binding("m", "focus_models", "Models"),
        Binding("c", "focus_chat", "Chat"),
        Binding("ctrl+enter", "send_message", "Send"),
    ]

    TITLE = "TriStar Terminal UI v2.80"
    SUB_TITLE = "TriForce MCP Server Management"

    status_text = reactive("Connecting...")

    def __init__(self, api_url: str = API_BASE):
        super().__init__()
        self.client = TriStarClient(api_url)
        self.prompts: List[str] = []
        self.current_prompt: Optional[str] = None

    def compose(self) -> ComposeResult:
        yield Header()
        with Container(id="main-container"):
            with TabbedContent():
                with TabPane("Logs", id="tab-logs"):
                    yield RichLog(id="log-viewer", highlight=True, markup=True)
                with TabPane("Chat", id="tab-chat"):
                    yield ChatPanel()
                with TabPane("Prompts", id="tab-prompts"):
                    yield PromptEditor()
                with TabPane("Settings", id="tab-settings"):
                    yield SettingsPanel()
                with TabPane("Models", id="tab-models"):
                    yield ModelDashboard()
                with TabPane("Agents", id="tab-agents"):
                    yield AgentPanel()
        yield Static(self.status_text, id="status-bar")
        yield Footer()

    async def on_mount(self) -> None:
        """Initialize the app"""
        self.refresh_logs()
        self.refresh_prompts()
        self.refresh_settings()
        self.refresh_models()
        self.refresh_agents()
        self.set_interval(10, self.refresh_logs)  # Auto-refresh logs every 10s

    @work(exclusive=True, group="logs")
    async def refresh_logs(self) -> None:
        """Refresh log viewer"""
        try:
            logs = await self.client.get_audit_logs(limit=200)
            log_viewer = self.query_one("#log-viewer", RichLog)
            log_viewer.clear()

            for entry in reversed(logs):
                timestamp = entry.get("timestamp", "")[:19]
                level = entry.get("level", "info")
                llm_id = entry.get("llm_id", "system")
                action = entry.get("action", "")

                level_colors = {
                    "debug": "dim",
                    "info": "cyan",
                    "warning": "yellow",
                    "error": "red",
                    "critical": "bold red",
                    "security": "magenta"
                }
                color = level_colors.get(level, "white")

                log_viewer.write(
                    f"[dim]{timestamp}[/dim] [{color}]{level.upper():8}[/{color}] "
                    f"[bold]{llm_id}[/bold]: {action}"
                )

            self.status_text = f"Logs: {len(logs)} entries | Last refresh: {datetime.now().strftime('%H:%M:%S')}"
        except Exception as e:
            self.status_text = f"Error loading logs: {e}"

    @work(exclusive=True, group="prompts")
    async def refresh_prompts(self) -> None:
        """Refresh prompts list"""
        try:
            self.prompts = await self.client.list_prompts()
            select = self.query_one("#prompt-select", Select)
            select.set_options([(p, p) for p in self.prompts])
        except Exception as e:
            self.notify(f"Error loading prompts: {e}", severity="error")

    @work(exclusive=True, group="settings")
    async def refresh_settings(self) -> None:
        """Refresh settings table"""
        try:
            settings = await self.client.get_settings()
            table = self.query_one("#settings-table", DataTable)
            table.clear(columns=True)
            table.add_columns("Key", "Value", "Type")

            for key, value in settings.get("settings", {}).items():
                value_str = json.dumps(value) if isinstance(value, (dict, list)) else str(value)
                table.add_row(key, value_str[:50], type(value).__name__)
        except Exception as e:
            self.notify(f"Error loading settings: {e}", severity="error")

    @work(exclusive=True, group="models")
    async def refresh_models(self) -> None:
        """Refresh models table"""
        try:
            models = await self.client.get_models()
            table = self.query_one("#models-table", DataTable)
            table.clear(columns=True)
            table.add_columns("Model ID", "Role", "Provider", "Status")

            for model in models[:50]:  # Limit display
                table.add_row(
                    model.get("id", ""),
                    model.get("role", "worker"),
                    model.get("provider", ""),
                    "âœ“" if model.get("initialized") else "â—‹"
                )
        except Exception as e:
            self.notify(f"Error loading models: {e}", severity="error")

    @work(exclusive=True, group="agents")
    async def refresh_agents(self) -> None:
        """Refresh agents table"""
        try:
            agents = await self.client.get_agents()
            table = self.query_one("#agents-table", DataTable)
            table.clear(columns=True)
            table.add_columns("Agent ID", "Type", "Status", "PID")

            for agent in agents:
                status_icon = "ðŸŸ¢" if agent.get("status") == "running" else "ðŸ”´"
                table.add_row(
                    agent.get("id", ""),
                    agent.get("type", ""),
                    f"{status_icon} {agent.get('status', 'stopped')}",
                    str(agent.get("pid", "-"))
                )
        except Exception as e:
            self.notify(f"Error loading agents: {e}", severity="error")

    async def on_button_pressed(self, event: Button.Pressed) -> None:
        """Handle button presses"""
        button_id = event.button.id

        if button_id == "btn-load-prompt":
            await self.load_prompt()
        elif button_id == "btn-save-prompt":
            await self.save_prompt()
        elif button_id == "btn-new-prompt":
            await self.new_prompt()
        elif button_id == "btn-set-setting":
            await self.set_setting()
        elif button_id == "btn-refresh-models":
            self.refresh_models()
        elif button_id == "btn-start-agent":
            await self.start_agent()
        elif button_id == "btn-stop-agent":
            await self.stop_agent()
        elif button_id == "btn-restart-agent":
            await self.restart_agent()

    async def on_input_submitted(self, event: Input.Submitted) -> None:
        """Handle input submission"""
        if event.input.id == "chat-input":
            await self.send_chat_message()

    @work(exclusive=True, group="prompt")
    async def load_prompt(self) -> None:
        """Load selected prompt"""
        try:
            select = self.query_one("#prompt-select", Select)
            if select.value:
                content = await self.client.get_prompt(select.value)
                editor = self.query_one("#prompt-editor", TextArea)
                editor.load_text(content)
                self.current_prompt = select.value
                self.notify(f"Loaded prompt: {select.value}")
        except Exception as e:
            self.notify(f"Error loading prompt: {e}", severity="error")

    @work(exclusive=True, group="prompt")
    async def save_prompt(self) -> None:
        """Save current prompt"""
        try:
            if not self.current_prompt:
                self.notify("No prompt selected", severity="warning")
                return

            editor = self.query_one("#prompt-editor", TextArea)
            content = editor.text
            await self.client.set_prompt(self.current_prompt, content)
            self.notify(f"Saved prompt: {self.current_prompt}", severity="information")
        except Exception as e:
            self.notify(f"Error saving prompt: {e}", severity="error")

    async def new_prompt(self) -> None:
        """Create new prompt"""
        # TODO: Add dialog for new prompt name
        self.notify("New prompt dialog not yet implemented", severity="warning")

    @work(exclusive=True, group="settings")
    async def set_setting(self) -> None:
        """Set a setting value"""
        try:
            key_input = self.query_one("#setting-key", Input)
            value_input = self.query_one("#setting-value", Input)

            if not key_input.value:
                self.notify("Please enter a key", severity="warning")
                return

            # Try to parse as JSON, fall back to string
            try:
                value = json.loads(value_input.value)
            except json.JSONDecodeError:
                value = value_input.value

            await self.client.set_setting(key_input.value, value)
            self.notify(f"Set {key_input.value} = {value}")
            self.refresh_settings()

            key_input.value = ""
            value_input.value = ""
        except Exception as e:
            self.notify(f"Error setting value: {e}", severity="error")

    @work(exclusive=True, group="agent")
    async def start_agent(self) -> None:
        """Start selected agent"""
        try:
            select = self.query_one("#agent-select", Select)
            if select.value:
                await self.client.mcp_tool_call("cli-agents_start", {"agent_id": select.value})
                self.notify(f"Started agent: {select.value}")
                self.refresh_agents()
        except Exception as e:
            self.notify(f"Error starting agent: {e}", severity="error")

    @work(exclusive=True, group="agent")
    async def stop_agent(self) -> None:
        """Stop selected agent"""
        try:
            select = self.query_one("#agent-select", Select)
            if select.value:
                await self.client.mcp_tool_call("cli-agents_stop", {"agent_id": select.value})
                self.notify(f"Stopped agent: {select.value}")
                self.refresh_agents()
        except Exception as e:
            self.notify(f"Error stopping agent: {e}", severity="error")

    @work(exclusive=True, group="agent")
    async def restart_agent(self) -> None:
        """Restart selected agent"""
        try:
            select = self.query_one("#agent-select", Select)
            if select.value:
                await self.client.mcp_tool_call("cli-agents_restart", {"agent_id": select.value})
                self.notify(f"Restarted agent: {select.value}")
                self.refresh_agents()
        except Exception as e:
            self.notify(f"Error restarting agent: {e}", severity="error")

    @work(exclusive=True, group="chat")
    async def send_chat_message(self) -> None:
        """Send chat message"""
        try:
            chat_input = self.query_one("#chat-input", Input)
            chat_output = self.query_one("#chat-output", RichLog)
            model_select = self.query_one("#model-select", Select)

            message = chat_input.value.strip()
            if not message:
                return

            model = model_select.value or "gemini/gemini-2.5-flash"

            # Show user message
            chat_output.write(f"\n[bold cyan]You:[/bold cyan] {message}")
            chat_input.value = ""

            # Get response
            chat_output.write(f"[dim]Waiting for {model}...[/dim]")
            response = await self.client.chat(message, model)

            # Show response
            chat_output.write(f"\n[bold green]{model}:[/bold green]")
            chat_output.write(response)

        except Exception as e:
            chat_output = self.query_one("#chat-output", RichLog)
            chat_output.write(f"[red]Error: {e}[/red]")

    def action_refresh(self) -> None:
        """Refresh all data"""
        self.refresh_logs()
        self.refresh_prompts()
        self.refresh_settings()
        self.refresh_models()
        self.refresh_agents()
        self.notify("Refreshed all data")

    def action_focus_logs(self) -> None:
        """Focus logs tab"""
        self.query_one(TabbedContent).active = "tab-logs"

    def action_focus_prompts(self) -> None:
        """Focus prompts tab"""
        self.query_one(TabbedContent).active = "tab-prompts"

    def action_focus_settings(self) -> None:
        """Focus settings tab"""
        self.query_one(TabbedContent).active = "tab-settings"

    def action_focus_models(self) -> None:
        """Focus models tab"""
        self.query_one(TabbedContent).active = "tab-models"

    def action_focus_chat(self) -> None:
        """Focus chat tab"""
        self.query_one(TabbedContent).active = "tab-chat"

    def action_send_message(self) -> None:
        """Send chat message (Ctrl+Enter)"""
        self.run_worker(self.send_chat_message())

    async def on_unmount(self) -> None:
        """Cleanup on exit"""
        await self.client.close()


def main():
    """Main entry point"""
    import argparse

    parser = argparse.ArgumentParser(description="TriStar Terminal UI")
    parser.add_argument("--api-url", default=API_BASE, help="API base URL")
    args = parser.parse_args()

    app = TriStarTUI(api_url=args.api_url)
    app.run()


if __name__ == "__main__":
    main()
